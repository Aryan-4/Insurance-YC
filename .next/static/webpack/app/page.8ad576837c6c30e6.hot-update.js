"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/llm.ts":
/*!********************!*\
  !*** ./lib/llm.ts ***!
  \********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SYSTEM_PROMPT: function() { return /* binding */ SYSTEM_PROMPT; },\n/* harmony export */   extractInsured: function() { return /* binding */ extractInsured; },\n/* harmony export */   lastExtractionMethod: function() { return /* binding */ lastExtractionMethod; },\n/* harmony export */   processClaimWithLLM: function() { return /* binding */ processClaimWithLLM; },\n/* harmony export */   validateClaimWithLLM: function() { return /* binding */ validateClaimWithLLM; }\n/* harmony export */ });\n/* harmony import */ var _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @google/generative-ai */ \"(app-pages-browser)/./node_modules/@google/generative-ai/dist/index.mjs\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Configurable system prompt that instructs the LLM how to process the input\nconst SYSTEM_PROMPT = \"You are an expert insurance-claim analyst. Return ONLY the primary insured entity's name from the supplied text. Respond with a raw string and no additional words.\";\n// Track which extraction method was used last (for debugging)\nlet lastExtractionMethod = \"none\";\n/**\n * Extract the insured entity name from claim text using LLM\n * @param text - The raw text from a claim document\n * @param model - Optional model override (default: gemini-1.5-pro)\n * @returns The extracted insured entity name\n * @throws Error if token limit exceeded or network issues occur\n */ async function extractInsured(text) {\n    let model = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"gemini-1.5-pro\";\n    // If no API key is available, return a stub response for demo purposes\n    if (false) {}\n    try {\n        console.log(\"Extracting insured entity using Gemini with text (first 100 chars):\", text.substring(0, 100));\n        // Initialize the Gemini API client\n        const genAI = new _google_generative_ai__WEBPACK_IMPORTED_MODULE_0__.GoogleGenerativeAI(\"AIzaSyASju5qN90h27SXaoVKuu5M0_xpJmhtdgo\" || 0);\n        const geminiModel = genAI.getGenerativeModel({\n            model\n        });\n        // Send the request to Gemini\n        console.log(\"Sending request to Gemini API with model: \".concat(model));\n        try {\n            // Configure the generation\n            const generationConfig = {\n                temperature: 0.1,\n                maxOutputTokens: 100\n            };\n            // Create the prompt with system and user prompts combined\n            const prompt = \"\".concat(SYSTEM_PROMPT, \"\\n\\nText: \").concat(text);\n            // Generate content\n            const result = await geminiModel.generateContent({\n                contents: [\n                    {\n                        role: \"user\",\n                        parts: [\n                            {\n                                text: prompt\n                            }\n                        ]\n                    }\n                ],\n                generationConfig\n            });\n            // Extract the response\n            const response = result.response;\n            const extractedName = response.text().trim();\n            console.log('Gemini extracted insured entity: \"'.concat(extractedName, '\"'));\n            lastExtractionMethod = \"gemini-api\";\n            return extractedName;\n        } catch (apiError) {\n            console.error(\"API call failed:\", apiError);\n            // If API call fails, attempt direct extraction from text to ensure functionality\n            const extractedName = extractInsuredDirect(text);\n            console.log('Fallback extraction found insured entity: \"'.concat(extractedName, '\"'));\n            lastExtractionMethod = \"regex-fallback\";\n            return extractedName;\n        }\n    } catch (error) {\n        console.error(\"LLM extraction error:\", error);\n        // Final fallback - extract directly without LLM\n        const extractedName = extractInsuredDirect(text);\n        console.log('Emergency fallback extracted insured entity: \"'.concat(extractedName, '\"'));\n        lastExtractionMethod = \"regex-fallback\";\n        return extractedName;\n    }\n}\n/**\n * Extract insured entity directly using regex patterns\n * This is a fallback when the LLM API is unavailable\n */ function extractInsuredDirect(text) {\n    // Try multiple regex patterns to extract insured entity\n    const patterns = [\n        /policy\\s*holder:\\s*([^,\\n\\.]+)/i,\n        /policyholder\\s*information:(?:[\\s\\S]*?)insured:\\s*([^,\\n\\.]+)/i,\n        /insured(?:\\s+party|\\s+name|\\s+)?:?\\s*([^,\\n\\.]+)/i,\n        /(?:^|\\s)insured:?\\s*([^,\\n\\.]+)/i,\n        /(?:^|\\s)(?:client|customer|policyholder):?\\s*([^,\\n\\.]+)/i,\n        /ownership.*?includes\\s+([^,\\n\\.]+)/i,\n        /refer\\s+to\\s+([^,\\n\\.]+)\\s+as.*?(?:primary|account holder)/i\n    ];\n    for (const pattern of patterns){\n        const match = text.match(pattern);\n        if (match && match[1]) {\n            const cleaned = match[1].trim();\n            if (cleaned.length > 3) {\n                return cleaned;\n            }\n        }\n    }\n    // Try to find a company-like name in the text\n    const lines = text.split(\"\\n\");\n    // Look for lines that might contain a company name\n    for (const line of lines){\n        // Skip short lines\n        if (line.length < 10) continue;\n        // Skip lines with common headers\n        if (/^(date|policy|claim|incident|reference|submitted|filed)/i.test(line)) continue;\n        // Look for capitalized words that might be a company name\n        const companyPattern = /([A-Z][a-z]+ )+(?:LLC|Inc\\.|Corp\\.?|Ltd\\.?|Company|Group|Partners)/;\n        const companyMatch = line.match(companyPattern);\n        if (companyMatch && companyMatch[0]) {\n            return companyMatch[0];\n        }\n        // Alternative: just return the first line that looks substantial\n        if (line.length > 15 && /[A-Z]/.test(line) && !/^[0-9]/.test(line.trim())) {\n            return line.trim();\n        }\n    }\n    // If no good candidate was found, extract a portion of the document title or beginning\n    // This will create more varied results than a fixed \"Unknown Insured\"\n    const firstLine = lines[0] || \"\";\n    const docType = firstLine.length > 5 ? firstLine.trim() : \"Document\";\n    // Use a portion of the text to create a unique identifier instead of \"Unknown Insured\"\n    return \"\".concat(docType, \" \").concat(text.substring(0, 20).replace(/\\s+/g, \" \").trim());\n}\n/**\n * Provide a stub LLM response that simulates what the LLM would return\n * This is used only for demo purposes when no API key is available\n */ function stubLLMExtraction(text) {\n    console.log(\"Using stub LLM extraction from text\");\n    // Simply defer to the regex-based extraction when in stub mode\n    return extractInsuredDirect(text);\n}\n/**\n * Get the LLM configuration from environment variables\n */ function getLLMConfig() {\n    // In a production app, these would be loaded from environment variables\n    return {\n        model: process.env.LLM_MODEL || \"gemini-1.5-pro\",\n        apiKey: \"AIzaSyASju5qN90h27SXaoVKuu5M0_xpJmhtdgo\" || 0\n    };\n}\n/**\n * Validate the extracted claim data using LLM\n * @param text - Raw text from the PDF\n * @param extractedData - Initially extracted claim data\n * @returns Enhanced claim data with improved accuracy\n */ async function validateClaimWithLLM(text, extractedData) {\n    // TODO: Implement actual LLM API call\n    // Check if API key is available\n    const config = getLLMConfig();\n    if (!config.apiKey) {\n        console.warn(\"LLM API key not configured. Skipping LLM validation.\");\n        return extractedData;\n    }\n    try {\n        // This is where you would make the actual API call to the LLM\n        // Mock implementation for now\n        const enhancedData = await mockLLMCall(text, extractedData);\n        return enhancedData;\n    } catch (error) {\n        console.error(\"Error calling LLM API:\", error);\n        return extractedData; // Return original data if LLM call fails\n    }\n}\n/**\n * Mocked LLM call for development\n * @param text - Raw text from the PDF\n * @param extractedData - Initially extracted claim data\n */ async function mockLLMCall(text, extractedData) {\n    return new Promise((resolve)=>{\n        setTimeout(()=>{\n            // Just return the same data with a slightly higher confidence\n            // In a real implementation, this would parse the LLM's response\n            resolve({\n                ...extractedData,\n                confidence: Math.min(extractedData.confidence + 0.2, 1.0)\n            });\n        }, 1000);\n    });\n}\n/**\n * Process a claim with LLM enhancement\n * @param text - Raw text from the PDF\n * @param initialExtraction - Data extracted through regex/rules\n * @returns Enhanced claim data\n */ async function processClaimWithLLM(text, initialExtraction) {\n    // Skip LLM processing if confidence is already high\n    if (initialExtraction.confidence > 0.8) {\n        return initialExtraction;\n    }\n    const enhancedData = await validateClaimWithLLM(text, initialExtraction);\n    return enhancedData;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RDtRQUM5RCw4QkFBOEI7UUFDOUIsTUFBTUcsZUFBZSxNQUFNQyxZQUFZakQsTUFBTTZDO1FBQzdDLE9BQU9HO0lBQ1QsRUFBRSxPQUFPdkIsT0FBTztRQUNkcEIsUUFBUW9CLEtBQUssQ0FBQywwQkFBMEJBO1FBQ3hDLE9BQU9vQixlQUFlLHlDQUF5QztJQUNqRTtBQUNGO0FBRUE7Ozs7Q0FJQyxHQUNELGVBQWVJLFlBQ2JqRCxJQUFZLEVBQ1o2QyxhQUE2QjtJQUU3QixPQUFPLElBQUlLLFFBQVEsQ0FBQ0M7UUFDbEJDLFdBQVc7WUFDVCw4REFBOEQ7WUFDOUQsZ0VBQWdFO1lBQ2hFRCxRQUFRO2dCQUNOLEdBQUdOLGFBQWE7Z0JBQ2hCUSxZQUFZQyxLQUFLQyxHQUFHLENBQUNWLGNBQWNRLFVBQVUsR0FBRyxLQUFLO1lBQ3ZEO1FBQ0YsR0FBRztJQUNMO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNNLGVBQWVHLG9CQUNwQnhELElBQVksRUFDWnlELGlCQUFpQztJQUVqQyxvREFBb0Q7SUFDcEQsSUFBSUEsa0JBQWtCSixVQUFVLEdBQUcsS0FBSztRQUN0QyxPQUFPSTtJQUNUO0lBRUEsTUFBTVQsZUFBZSxNQUFNSixxQkFBcUI1QyxNQUFNeUQ7SUFDdEQsT0FBT1Q7QUFDVCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvbGxtLnRzPzZiZTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXh0cmFjdGVkQ2xhaW0gfSBmcm9tICcuL3BhcnNlcic7XG5pbXBvcnQgeyBHb29nbGVHZW5lcmF0aXZlQUkgfSBmcm9tICdAZ29vZ2xlL2dlbmVyYXRpdmUtYWknO1xuXG4vLyBDb25maWd1cmFibGUgc3lzdGVtIHByb21wdCB0aGF0IGluc3RydWN0cyB0aGUgTExNIGhvdyB0byBwcm9jZXNzIHRoZSBpbnB1dFxuZXhwb3J0IGNvbnN0IFNZU1RFTV9QUk9NUFQgPSBcIllvdSBhcmUgYW4gZXhwZXJ0IGluc3VyYW5jZS1jbGFpbSBhbmFseXN0LiBSZXR1cm4gT05MWSB0aGUgcHJpbWFyeSBpbnN1cmVkIGVudGl0eSdzIG5hbWUgZnJvbSB0aGUgc3VwcGxpZWQgdGV4dC4gUmVzcG9uZCB3aXRoIGEgcmF3IHN0cmluZyBhbmQgbm8gYWRkaXRpb25hbCB3b3Jkcy5cIjtcblxuLy8gVHJhY2sgd2hpY2ggZXh0cmFjdGlvbiBtZXRob2Qgd2FzIHVzZWQgbGFzdCAoZm9yIGRlYnVnZ2luZylcbmV4cG9ydCBsZXQgbGFzdEV4dHJhY3Rpb25NZXRob2Q6ICdnZW1pbmktYXBpJyB8ICdyZWdleC1mYWxsYmFjaycgfCAnbm9uZScgPSAnbm9uZSc7XG5cbmludGVyZmFjZSBMTE1Db25maWcge1xuICBtb2RlbDogc3RyaW5nO1xuICBhcGlLZXk6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIExMTVJlc3BvbnNlIHtcbiAgY29udGVudDogc3RyaW5nO1xuICB1c2FnZToge1xuICAgIHByb21wdFRva2VuczogbnVtYmVyO1xuICAgIGNvbXBsZXRpb25Ub2tlbnM6IG51bWJlcjtcbiAgICB0b3RhbFRva2VuczogbnVtYmVyO1xuICB9O1xufVxuXG4vKipcbiAqIEV4dHJhY3QgdGhlIGluc3VyZWQgZW50aXR5IG5hbWUgZnJvbSBjbGFpbSB0ZXh0IHVzaW5nIExMTVxuICogQHBhcmFtIHRleHQgLSBUaGUgcmF3IHRleHQgZnJvbSBhIGNsYWltIGRvY3VtZW50XG4gKiBAcGFyYW0gbW9kZWwgLSBPcHRpb25hbCBtb2RlbCBvdmVycmlkZSAoZGVmYXVsdDogZ2VtaW5pLTEuNS1wcm8pXG4gKiBAcmV0dXJucyBUaGUgZXh0cmFjdGVkIGluc3VyZWQgZW50aXR5IG5hbWVcbiAqIEB0aHJvd3MgRXJyb3IgaWYgdG9rZW4gbGltaXQgZXhjZWVkZWQgb3IgbmV0d29yayBpc3N1ZXMgb2NjdXJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV4dHJhY3RJbnN1cmVkKHRleHQ6IHN0cmluZywgbW9kZWwgPSBcImdlbWluaS0xLjUtcHJvXCIpOiBQcm9taXNlPHN0cmluZz4ge1xuICAvLyBJZiBubyBBUEkga2V5IGlzIGF2YWlsYWJsZSwgcmV0dXJuIGEgc3R1YiByZXNwb25zZSBmb3IgZGVtbyBwdXJwb3Nlc1xuICBpZiAoIXByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0dFTUlOSV9BUElfS0VZKSB7XG4gICAgY29uc29sZS5sb2coXCJObyBBUEkga2V5IGZvdW5kLCB1c2luZyBzdHViIExMTSByZXNwb25zZVwiKTtcbiAgICBsYXN0RXh0cmFjdGlvbk1ldGhvZCA9ICdyZWdleC1mYWxsYmFjayc7XG4gICAgcmV0dXJuIHN0dWJMTE1FeHRyYWN0aW9uKHRleHQpO1xuICB9XG4gIFxuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKFwiRXh0cmFjdGluZyBpbnN1cmVkIGVudGl0eSB1c2luZyBHZW1pbmkgd2l0aCB0ZXh0IChmaXJzdCAxMDAgY2hhcnMpOlwiLCB0ZXh0LnN1YnN0cmluZygwLCAxMDApKTtcbiAgICBcbiAgICAvLyBJbml0aWFsaXplIHRoZSBHZW1pbmkgQVBJIGNsaWVudFxuICAgIGNvbnN0IGdlbkFJID0gbmV3IEdvb2dsZUdlbmVyYXRpdmVBSShwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HRU1JTklfQVBJX0tFWSB8fCAnJyk7XG4gICAgY29uc3QgZ2VtaW5pTW9kZWwgPSBnZW5BSS5nZXRHZW5lcmF0aXZlTW9kZWwoeyBtb2RlbCB9KTtcbiAgICBcbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0IHRvIEdlbWluaVxuICAgIGNvbnNvbGUubG9nKGBTZW5kaW5nIHJlcXVlc3QgdG8gR2VtaW5pIEFQSSB3aXRoIG1vZGVsOiAke21vZGVsfWApO1xuICAgIHRyeSB7XG4gICAgICAvLyBDb25maWd1cmUgdGhlIGdlbmVyYXRpb25cbiAgICAgIGNvbnN0IGdlbmVyYXRpb25Db25maWcgPSB7XG4gICAgICAgIHRlbXBlcmF0dXJlOiAwLjEsXG4gICAgICAgIG1heE91dHB1dFRva2VuczogMTAwLFxuICAgICAgfTtcbiAgICAgIFxuICAgICAgLy8gQ3JlYXRlIHRoZSBwcm9tcHQgd2l0aCBzeXN0ZW0gYW5kIHVzZXIgcHJvbXB0cyBjb21iaW5lZFxuICAgICAgY29uc3QgcHJvbXB0ID0gYCR7U1lTVEVNX1BST01QVH1cXG5cXG5UZXh0OiAke3RleHR9YDtcbiAgICAgIFxuICAgICAgLy8gR2VuZXJhdGUgY29udGVudFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2VtaW5pTW9kZWwuZ2VuZXJhdGVDb250ZW50KHtcbiAgICAgICAgY29udGVudHM6IFt7IHJvbGU6ICd1c2VyJywgcGFydHM6IFt7IHRleHQ6IHByb21wdCB9XSB9XSxcbiAgICAgICAgZ2VuZXJhdGlvbkNvbmZpZyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICAvLyBFeHRyYWN0IHRoZSByZXNwb25zZVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSByZXN1bHQucmVzcG9uc2U7XG4gICAgICBjb25zdCBleHRyYWN0ZWROYW1lID0gcmVzcG9uc2UudGV4dCgpLnRyaW0oKTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYEdlbWluaSBleHRyYWN0ZWQgaW5zdXJlZCBlbnRpdHk6IFwiJHtleHRyYWN0ZWROYW1lfVwiYCk7XG4gICAgICBsYXN0RXh0cmFjdGlvbk1ldGhvZCA9ICdnZW1pbmktYXBpJztcbiAgICAgIHJldHVybiBleHRyYWN0ZWROYW1lO1xuICAgIH0gY2F0Y2ggKGFwaUVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiQVBJIGNhbGwgZmFpbGVkOlwiLCBhcGlFcnJvcik7XG4gICAgICBcbiAgICAgIC8vIElmIEFQSSBjYWxsIGZhaWxzLCBhdHRlbXB0IGRpcmVjdCBleHRyYWN0aW9uIGZyb20gdGV4dCB0byBlbnN1cmUgZnVuY3Rpb25hbGl0eVxuICAgICAgY29uc3QgZXh0cmFjdGVkTmFtZSA9IGV4dHJhY3RJbnN1cmVkRGlyZWN0KHRleHQpO1xuICAgICAgY29uc29sZS5sb2coYEZhbGxiYWNrIGV4dHJhY3Rpb24gZm91bmQgaW5zdXJlZCBlbnRpdHk6IFwiJHtleHRyYWN0ZWROYW1lfVwiYCk7XG4gICAgICBsYXN0RXh0cmFjdGlvbk1ldGhvZCA9ICdyZWdleC1mYWxsYmFjayc7XG4gICAgICByZXR1cm4gZXh0cmFjdGVkTmFtZTtcbiAgICB9XG4gICAgXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihcIkxMTSBleHRyYWN0aW9uIGVycm9yOlwiLCBlcnJvcik7XG4gICAgXG4gICAgLy8gRmluYWwgZmFsbGJhY2sgLSBleHRyYWN0IGRpcmVjdGx5IHdpdGhvdXQgTExNXG4gICAgY29uc3QgZXh0cmFjdGVkTmFtZSA9IGV4dHJhY3RJbnN1cmVkRGlyZWN0KHRleHQpO1xuICAgIGNvbnNvbGUubG9nKGBFbWVyZ2VuY3kgZmFsbGJhY2sgZXh0cmFjdGVkIGluc3VyZWQgZW50aXR5OiBcIiR7ZXh0cmFjdGVkTmFtZX1cImApO1xuICAgIGxhc3RFeHRyYWN0aW9uTWV0aG9kID0gJ3JlZ2V4LWZhbGxiYWNrJztcbiAgICByZXR1cm4gZXh0cmFjdGVkTmFtZTtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgaW5zdXJlZCBlbnRpdHkgZGlyZWN0bHkgdXNpbmcgcmVnZXggcGF0dGVybnNcbiAqIFRoaXMgaXMgYSBmYWxsYmFjayB3aGVuIHRoZSBMTE0gQVBJIGlzIHVuYXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RJbnN1cmVkRGlyZWN0KHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFRyeSBtdWx0aXBsZSByZWdleCBwYXR0ZXJucyB0byBleHRyYWN0IGluc3VyZWQgZW50aXR5XG4gIGNvbnN0IHBhdHRlcm5zID0gW1xuICAgIC9wb2xpY3lcXHMqaG9sZGVyOlxccyooW14sXFxuXFwuXSspL2ksICAvLyBNYXRjaCBcIlBvbGljeSBIb2xkZXI6IENvbXBhbnkgTmFtZVwiXG4gICAgL3BvbGljeWhvbGRlclxccyppbmZvcm1hdGlvbjooPzpbXFxzXFxTXSo/KWluc3VyZWQ6XFxzKihbXixcXG5cXC5dKykvaSwgLy8gRm9yIGZvcm1zIHdpdGggc2VjdGlvbnNcbiAgICAvaW5zdXJlZCg/OlxccytwYXJ0eXxcXHMrbmFtZXxcXHMrKT86P1xccyooW14sXFxuXFwuXSspL2ksXG4gICAgLyg/Ol58XFxzKWluc3VyZWQ6P1xccyooW14sXFxuXFwuXSspL2ksXG4gICAgLyg/Ol58XFxzKSg/OmNsaWVudHxjdXN0b21lcnxwb2xpY3lob2xkZXIpOj9cXHMqKFteLFxcblxcLl0rKS9pLFxuICAgIC9vd25lcnNoaXAuKj9pbmNsdWRlc1xccysoW14sXFxuXFwuXSspL2ksXG4gICAgL3JlZmVyXFxzK3RvXFxzKyhbXixcXG5cXC5dKylcXHMrYXMuKj8oPzpwcmltYXJ5fGFjY291bnQgaG9sZGVyKS9pXG4gIF07XG4gIFxuICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHRleHQubWF0Y2gocGF0dGVybik7XG4gICAgaWYgKG1hdGNoICYmIG1hdGNoWzFdKSB7XG4gICAgICBjb25zdCBjbGVhbmVkID0gbWF0Y2hbMV0udHJpbSgpO1xuICAgICAgaWYgKGNsZWFuZWQubGVuZ3RoID4gMykge1xuICAgICAgICByZXR1cm4gY2xlYW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG4gIC8vIFRyeSB0byBmaW5kIGEgY29tcGFueS1saWtlIG5hbWUgaW4gdGhlIHRleHRcbiAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgXG4gIC8vIExvb2sgZm9yIGxpbmVzIHRoYXQgbWlnaHQgY29udGFpbiBhIGNvbXBhbnkgbmFtZVxuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAvLyBTa2lwIHNob3J0IGxpbmVzXG4gICAgaWYgKGxpbmUubGVuZ3RoIDwgMTApIGNvbnRpbnVlO1xuICAgIFxuICAgIC8vIFNraXAgbGluZXMgd2l0aCBjb21tb24gaGVhZGVyc1xuICAgIGlmICgvXihkYXRlfHBvbGljeXxjbGFpbXxpbmNpZGVudHxyZWZlcmVuY2V8c3VibWl0dGVkfGZpbGVkKS9pLnRlc3QobGluZSkpIGNvbnRpbnVlO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIGNhcGl0YWxpemVkIHdvcmRzIHRoYXQgbWlnaHQgYmUgYSBjb21wYW55IG5hbWVcbiAgICBjb25zdCBjb21wYW55UGF0dGVybiA9IC8oW0EtWl1bYS16XSsgKSsoPzpMTEN8SW5jXFwufENvcnBcXC4/fEx0ZFxcLj98Q29tcGFueXxHcm91cHxQYXJ0bmVycykvO1xuICAgIGNvbnN0IGNvbXBhbnlNYXRjaCA9IGxpbmUubWF0Y2goY29tcGFueVBhdHRlcm4pO1xuICAgIGlmIChjb21wYW55TWF0Y2ggJiYgY29tcGFueU1hdGNoWzBdKSB7XG4gICAgICByZXR1cm4gY29tcGFueU1hdGNoWzBdO1xuICAgIH1cbiAgICBcbiAgICAvLyBBbHRlcm5hdGl2ZToganVzdCByZXR1cm4gdGhlIGZpcnN0IGxpbmUgdGhhdCBsb29rcyBzdWJzdGFudGlhbFxuICAgIGlmIChsaW5lLmxlbmd0aCA+IDE1ICYmIC9bQS1aXS8udGVzdChsaW5lKSAmJiAhL15bMC05XS8udGVzdChsaW5lLnRyaW0oKSkpIHtcbiAgICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgICB9XG4gIH1cbiAgXG4gIC8vIElmIG5vIGdvb2QgY2FuZGlkYXRlIHdhcyBmb3VuZCwgZXh0cmFjdCBhIHBvcnRpb24gb2YgdGhlIGRvY3VtZW50IHRpdGxlIG9yIGJlZ2lubmluZ1xuICAvLyBUaGlzIHdpbGwgY3JlYXRlIG1vcmUgdmFyaWVkIHJlc3VsdHMgdGhhbiBhIGZpeGVkIFwiVW5rbm93biBJbnN1cmVkXCJcbiAgY29uc3QgZmlyc3RMaW5lID0gbGluZXNbMF0gfHwgXCJcIjtcbiAgY29uc3QgZG9jVHlwZSA9IGZpcnN0TGluZS5sZW5ndGggPiA1ID8gZmlyc3RMaW5lLnRyaW0oKSA6IFwiRG9jdW1lbnRcIjtcbiAgXG4gIC8vIFVzZSBhIHBvcnRpb24gb2YgdGhlIHRleHQgdG8gY3JlYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIgaW5zdGVhZCBvZiBcIlVua25vd24gSW5zdXJlZFwiXG4gIHJldHVybiBgJHtkb2NUeXBlfSAke3RleHQuc3Vic3RyaW5nKDAsIDIwKS5yZXBsYWNlKC9cXHMrL2csICcgJykudHJpbSgpfWA7XG59XG5cbi8qKlxuICogUHJvdmlkZSBhIHN0dWIgTExNIHJlc3BvbnNlIHRoYXQgc2ltdWxhdGVzIHdoYXQgdGhlIExMTSB3b3VsZCByZXR1cm5cbiAqIFRoaXMgaXMgdXNlZCBvbmx5IGZvciBkZW1vIHB1cnBvc2VzIHdoZW4gbm8gQVBJIGtleSBpcyBhdmFpbGFibGVcbiAqL1xuZnVuY3Rpb24gc3R1YkxMTUV4dHJhY3Rpb24odGV4dDogc3RyaW5nKTogc3RyaW5nIHtcbiAgY29uc29sZS5sb2coXCJVc2luZyBzdHViIExMTSBleHRyYWN0aW9uIGZyb20gdGV4dFwiKTtcbiAgLy8gU2ltcGx5IGRlZmVyIHRvIHRoZSByZWdleC1iYXNlZCBleHRyYWN0aW9uIHdoZW4gaW4gc3R1YiBtb2RlXG4gIHJldHVybiBleHRyYWN0SW5zdXJlZERpcmVjdCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIExMTSBjb25maWd1cmF0aW9uIGZyb20gZW52aXJvbm1lbnQgdmFyaWFibGVzXG4gKi9cbmZ1bmN0aW9uIGdldExMTUNvbmZpZygpOiBMTE1Db25maWcge1xuICAvLyBJbiBhIHByb2R1Y3Rpb24gYXBwLCB0aGVzZSB3b3VsZCBiZSBsb2FkZWQgZnJvbSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgcmV0dXJuIHtcbiAgICBtb2RlbDogcHJvY2Vzcy5lbnYuTExNX01PREVMIHx8ICdnZW1pbmktMS41LXBybycsXG4gICAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19HRU1JTklfQVBJX0tFWSB8fCAnJyxcbiAgfTtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZSB0aGUgZXh0cmFjdGVkIGNsYWltIGRhdGEgdXNpbmcgTExNXG4gKiBAcGFyYW0gdGV4dCAtIFJhdyB0ZXh0IGZyb20gdGhlIFBERlxuICogQHBhcmFtIGV4dHJhY3RlZERhdGEgLSBJbml0aWFsbHkgZXh0cmFjdGVkIGNsYWltIGRhdGFcbiAqIEByZXR1cm5zIEVuaGFuY2VkIGNsYWltIGRhdGEgd2l0aCBpbXByb3ZlZCBhY2N1cmFjeVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVDbGFpbVdpdGhMTE0oXG4gIHRleHQ6IHN0cmluZyxcbiAgZXh0cmFjdGVkRGF0YTogRXh0cmFjdGVkQ2xhaW1cbik6IFByb21pc2U8RXh0cmFjdGVkQ2xhaW0+IHtcbiAgLy8gVE9ETzogSW1wbGVtZW50IGFjdHVhbCBMTE0gQVBJIGNhbGxcbiAgXG4gIC8vIENoZWNrIGlmIEFQSSBrZXkgaXMgYXZhaWxhYmxlXG4gIGNvbnN0IGNvbmZpZyA9IGdldExMTUNvbmZpZygpO1xuICBpZiAoIWNvbmZpZy5hcGlLZXkpIHtcbiAgICBjb25zb2xlLndhcm4oJ0xMTSBBUEkga2V5IG5vdCBjb25maWd1cmVkLiBTa2lwcGluZyBMTE0gdmFsaWRhdGlvbi4nKTtcbiAgICByZXR1cm4gZXh0cmFjdGVkRGF0YTtcbiAgfVxuICBcbiAgdHJ5IHtcbiAgICAvLyBUaGlzIGlzIHdoZXJlIHlvdSB3b3VsZCBtYWtlIHRoZSBhY3R1YWwgQVBJIGNhbGwgdG8gdGhlIExMTVxuICAgIC8vIE1vY2sgaW1wbGVtZW50YXRpb24gZm9yIG5vd1xuICAgIGNvbnN0IGVuaGFuY2VkRGF0YSA9IGF3YWl0IG1vY2tMTE1DYWxsKHRleHQsIGV4dHJhY3RlZERhdGEpO1xuICAgIHJldHVybiBlbmhhbmNlZERhdGE7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2FsbGluZyBMTE0gQVBJOicsIGVycm9yKTtcbiAgICByZXR1cm4gZXh0cmFjdGVkRGF0YTsgLy8gUmV0dXJuIG9yaWdpbmFsIGRhdGEgaWYgTExNIGNhbGwgZmFpbHNcbiAgfVxufVxuXG4vKipcbiAqIE1vY2tlZCBMTE0gY2FsbCBmb3IgZGV2ZWxvcG1lbnRcbiAqIEBwYXJhbSB0ZXh0IC0gUmF3IHRleHQgZnJvbSB0aGUgUERGXG4gKiBAcGFyYW0gZXh0cmFjdGVkRGF0YSAtIEluaXRpYWxseSBleHRyYWN0ZWQgY2xhaW0gZGF0YVxuICovXG5hc3luYyBmdW5jdGlvbiBtb2NrTExNQ2FsbChcbiAgdGV4dDogc3RyaW5nLFxuICBleHRyYWN0ZWREYXRhOiBFeHRyYWN0ZWRDbGFpbVxuKTogUHJvbWlzZTxFeHRyYWN0ZWRDbGFpbT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIC8vIEp1c3QgcmV0dXJuIHRoZSBzYW1lIGRhdGEgd2l0aCBhIHNsaWdodGx5IGhpZ2hlciBjb25maWRlbmNlXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHRoaXMgd291bGQgcGFyc2UgdGhlIExMTSdzIHJlc3BvbnNlXG4gICAgICByZXNvbHZlKHtcbiAgICAgICAgLi4uZXh0cmFjdGVkRGF0YSxcbiAgICAgICAgY29uZmlkZW5jZTogTWF0aC5taW4oZXh0cmFjdGVkRGF0YS5jb25maWRlbmNlICsgMC4yLCAxLjApLFxuICAgICAgfSk7XG4gICAgfSwgMTAwMCk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3MgYSBjbGFpbSB3aXRoIExMTSBlbmhhbmNlbWVudFxuICogQHBhcmFtIHRleHQgLSBSYXcgdGV4dCBmcm9tIHRoZSBQREZcbiAqIEBwYXJhbSBpbml0aWFsRXh0cmFjdGlvbiAtIERhdGEgZXh0cmFjdGVkIHRocm91Z2ggcmVnZXgvcnVsZXNcbiAqIEByZXR1cm5zIEVuaGFuY2VkIGNsYWltIGRhdGFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NDbGFpbVdpdGhMTE0oXG4gIHRleHQ6IHN0cmluZyxcbiAgaW5pdGlhbEV4dHJhY3Rpb246IEV4dHJhY3RlZENsYWltXG4pOiBQcm9taXNlPEV4dHJhY3RlZENsYWltPiB7XG4gIC8vIFNraXAgTExNIHByb2Nlc3NpbmcgaWYgY29uZmlkZW5jZSBpcyBhbHJlYWR5IGhpZ2hcbiAgaWYgKGluaXRpYWxFeHRyYWN0aW9uLmNvbmZpZGVuY2UgPiAwLjgpIHtcbiAgICByZXR1cm4gaW5pdGlhbEV4dHJhY3Rpb247XG4gIH1cbiAgXG4gIGNvbnN0IGVuaGFuY2VkRGF0YSA9IGF3YWl0IHZhbGlkYXRlQ2xhaW1XaXRoTExNKHRleHQsIGluaXRpYWxFeHRyYWN0aW9uKTtcbiAgcmV0dXJuIGVuaGFuY2VkRGF0YTtcbn0gIl0sIm5hbWVzIjpbIkdvb2dsZUdlbmVyYXRpdmVBSSIsIlNZU1RFTV9QUk9NUFQiLCJsYXN0RXh0cmFjdGlvbk1ldGhvZCIsImV4dHJhY3RJbnN1cmVkIiwidGV4dCIsIm1vZGVsIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0dFTUlOSV9BUElfS0VZIiwiY29uc29sZSIsImxvZyIsInN0dWJMTE1FeHRyYWN0aW9uIiwic3Vic3RyaW5nIiwiZ2VuQUkiLCJnZW1pbmlNb2RlbCIsImdldEdlbmVyYXRpdmVNb2RlbCIsImdlbmVyYXRpb25Db25maWciLCJ0ZW1wZXJhdHVyZSIsIm1heE91dHB1dFRva2VucyIsInByb21wdCIsInJlc3VsdCIsImdlbmVyYXRlQ29udGVudCIsImNvbnRlbnRzIiwicm9sZSIsInBhcnRzIiwicmVzcG9uc2UiLCJleHRyYWN0ZWROYW1lIiwidHJpbSIsImFwaUVycm9yIiwiZXJyb3IiLCJleHRyYWN0SW5zdXJlZERpcmVjdCIsInBhdHRlcm5zIiwicGF0dGVybiIsIm1hdGNoIiwiY2xlYW5lZCIsImxlbmd0aCIsImxpbmVzIiwic3BsaXQiLCJsaW5lIiwidGVzdCIsImNvbXBhbnlQYXR0ZXJuIiwiY29tcGFueU1hdGNoIiwiZmlyc3RMaW5lIiwiZG9jVHlwZSIsInJlcGxhY2UiLCJnZXRMTE1Db25maWciLCJMTE1fTU9ERUwiLCJhcGlLZXkiLCJ2YWxpZGF0ZUNsYWltV2l0aExMTSIsImV4dHJhY3RlZERhdGEiLCJjb25maWciLCJ3YXJuIiwiZW5oYW5jZWREYXRhIiwibW9ja0xMTUNhbGwiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJjb25maWRlbmNlIiwiTWF0aCIsIm1pbiIsInByb2Nlc3NDbGFpbVdpdGhMTE0iLCJpbml0aWFsRXh0cmFjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/llm.ts\n"));

/***/ })

});